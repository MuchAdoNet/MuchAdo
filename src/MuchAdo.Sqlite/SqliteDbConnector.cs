using System.Data;
using System.Data.Common;
using Microsoft.Data.Sqlite;

namespace MuchAdo.Sqlite;

/// <summary>
/// A <see cref="DbConnector" /> optimized for Microsoft.Data.Sqlite.
/// </summary>
public class SqliteDbConnector : DbConnector
{
	public SqliteDbConnector(DbConnection connection)
		: this(connection, SqliteDbConnectorSettings.Default)
	{
	}

	public SqliteDbConnector(DbConnection connection, SqliteDbConnectorSettings settings)
		: base(connection, settings)
	{
		if (connection is not SqliteConnection)
			throw new ArgumentException("The connection must be a SqliteConnection.", nameof(connection));
	}

	public new SqliteConnection Connection => (SqliteConnection) base.Connection;

	public new SqliteTransaction? Transaction => (SqliteTransaction?) base.Transaction;

	public new SqliteCommand? ActiveCommand => (SqliteCommand?) base.ActiveCommand;

	public new SqliteDataReader? ActiveReader => (SqliteDataReader?) base.ActiveReader;

	public new SqliteConnection GetOpenConnection() => (SqliteConnection) base.GetOpenConnection();

	public new ValueTask<SqliteConnection> GetOpenConnectionAsync(CancellationToken cancellationToken = default)
	{
		var task = base.GetOpenConnectionAsync(cancellationToken);
		return task.IsCompletedSuccessfully ? new ValueTask<SqliteConnection>((SqliteConnection) task.Result) : DoAsync(task);
		static async ValueTask<SqliteConnection> DoAsync(ValueTask<IDbConnection> t) => (SqliteConnection) await t.ConfigureAwait(false);
	}

	protected override object CreateBatchCore() => new SqliteBatch(Connection);

	protected override void AddBatchCommandCore(CommandType commandType)
	{
		if (ActiveCommandOrBatch is SqliteBatch batch)
		{
			batch.AddCommand(commandType);
			return;
		}

		base.AddBatchCommandCore(commandType);
	}

	protected override void SetTimeoutCore(int timeout)
	{
		if (ActiveCommandOrBatch is SqliteBatch batch)
		{
			batch.SetTimeout(timeout);
			return;
		}

		base.SetTimeoutCore(timeout);
	}

	protected override void SetTransactionCore(IDbTransaction? transaction)
	{
		if (ActiveCommandOrBatch is SqliteBatch batch)
		{
			batch.SetTransaction((SqliteTransaction?) transaction);
			return;
		}

		base.SetTransactionCore(transaction);
	}

	protected override void SetCommandTextCore(int commandIndex, string commandText)
	{
		// SQL text is generated by MuchAdo (SqlSource/SqlFormatStringHandler) and parameters are submitted separately.
		// This is a low-level provider hook, so suppress CA2100-style warnings here.
#pragma warning disable CA2100
		if (ActiveCommandOrBatch is SqliteBatch batch)
		{
			batch.Commands[commandIndex].CommandText = commandText;
			return;
		}
#pragma warning restore CA2100

		base.SetCommandTextCore(commandIndex, commandText);
	}

	protected override IDataParameterCollection GetParameterCollectionCore(int commandIndex)
	{
		if (ActiveCommandOrBatch is SqliteBatch batch)
			return batch.Commands[commandIndex].Parameters;

		return base.GetParameterCollectionCore(commandIndex);
	}

	protected override int ExecuteNonQueryCore()
	{
		if (ActiveCommandOrBatch is SqliteBatch batch)
		{
			var total = 0;
			foreach (var cmd in batch.Commands)
				total += cmd.ExecuteNonQuery();
			return total;
		}

		return base.ExecuteNonQueryCore();
	}

	protected override async ValueTask<int> ExecuteNonQueryCoreAsync(CancellationToken cancellationToken)
	{
		if (ActiveCommandOrBatch is SqliteBatch batch)
		{
			var total = 0;
			foreach (var cmd in batch.Commands)
				total += await cmd.ExecuteNonQueryAsync(cancellationToken).ConfigureAwait(false);
			return total;
		}

		return await base.ExecuteNonQueryCoreAsync(cancellationToken).ConfigureAwait(false);
	}

	protected override IDataReader ExecuteReaderCore()
	{
		if (ActiveCommandOrBatch is SqliteBatch batch)
		{
			// Sqlite doesn't support DbBatch/CreateBatch; SqliteBatchDataReader emulates NextResult() across commands.
			return new SqliteBatchDataReader(batch, CommandBehavior.Default);
		}

		return base.ExecuteReaderCore();
	}

	protected override ValueTask<IDataReader> ExecuteReaderCoreAsync(CancellationToken cancellationToken)
	{
		if (ActiveCommandOrBatch is SqliteBatch batch)
			return new ValueTask<IDataReader>(new SqliteBatchDataReader(batch, CommandBehavior.Default));

		return base.ExecuteReaderCoreAsync(cancellationToken);
	}

	protected override IDataReader ExecuteReaderCore(CommandBehavior commandBehavior)
	{
		if (ActiveCommandOrBatch is SqliteBatch batch)
			return new SqliteBatchDataReader(batch, commandBehavior);

		return base.ExecuteReaderCore(commandBehavior);
	}

	protected override ValueTask<IDataReader> ExecuteReaderCoreAsync(CommandBehavior commandBehavior, CancellationToken cancellationToken)
	{
		if (ActiveCommandOrBatch is SqliteBatch batch)
			return new ValueTask<IDataReader>(new SqliteBatchDataReader(batch, commandBehavior));

		return base.ExecuteReaderCoreAsync(commandBehavior, cancellationToken);
	}

	protected override void PrepareCore()
	{
		if (ActiveCommandOrBatch is SqliteBatch batch)
		{
			batch.Prepare();
			return;
		}

		base.PrepareCore();
	}

	protected override ValueTask PrepareCoreAsync(CancellationToken cancellationToken)
	{
		if (ActiveCommandOrBatch is SqliteBatch batch)
			return batch.PrepareAsync(cancellationToken);

		return base.PrepareCoreAsync(cancellationToken);
	}

	protected override void CancelCore()
	{
		if (ActiveCommandOrBatch is SqliteBatch batch)
		{
			batch.Cancel();
			return;
		}

		base.CancelCore();
	}

	protected override void DisposeCommandOrBatchCore()
	{
		if (ActiveCommandOrBatch is SqliteBatch batch)
		{
			batch.Dispose();
			return;
		}

		base.DisposeCommandOrBatchCore();
	}

	protected override ValueTask DisposeCommandOrBatchCoreAsync()
	{
		if (ActiveCommandOrBatch is SqliteBatch batch)
			return batch.DisposeAsync();

		return base.DisposeCommandOrBatchCoreAsync();
	}

	protected override IDbTransaction BeginTransactionCore(DbTransactionSettings settings)
	{
		if (settings is SqliteDbTransactionSettings sqliteSettings)
		{
			return sqliteSettings.IsolationLevel is { } isolationLevel
				? Connection.BeginTransaction(isolationLevel, sqliteSettings.IsDeferred)
				: Connection.BeginTransaction(sqliteSettings.IsDeferred);
		}

		return base.BeginTransactionCore(settings);
	}

	protected override ValueTask<IDbTransaction> BeginTransactionCoreAsync(DbTransactionSettings settings, CancellationToken cancellationToken) =>
		new(BeginTransactionCore(settings));

	protected override IDataParameter CreateParameterCore<T>(string name, T value) => new SqliteParameter(name, value);
}
